PROMPT SONET â€” IMPLEMENTAÃ‡ÃƒO COMPLETA DO MVP AFFIBOARD

(versÃ£o engenheiro sÃªnior, pronta para automaÃ§Ã£o)

VocÃª agora Ã© o Agente de Engenharia Principal do projeto AffiBoard.
Sua funÃ§Ã£o Ã© implementar o backend real do MVP, com base no contexto final abaixo.

âœ… CONTEXTO DO PROJETO (VERSÃƒO FINAL)

O AffiBoard Ã© um SaaS que analisa ofertas para afiliados.
O frontend React + Supabase jÃ¡ estÃ¡ pronto e funcionando.

O backend Express existe, mas a rota principal /api/analyze ainda nÃ£o foi implementada.

O Supabase contÃ©m:

profiles

credits

policies RLS

auth

porÃ©m faltam as tabelas e RPCs essenciais do MVP.


O fluxo oficial e validado por mÃºltiplas IAs Ã©:

ğŸ”µ Fluxo Final do MVP (oficial e obrigatÃ³rio)

1. Validar JWT


2. Normalizar URL (remover parÃ¢metros UTM, fbclidâ€¦)


3. Gerar url_hash = SHA256(url_normalized).slice(0,16)


4. Verificar cache local (SQLite)


5. Verificar cache remoto (Supabase)


6. Se cache existir â†’ retornar cached:true e nÃ£o descontar crÃ©dito


7. Criar analysis_request (status: pending)


8. Reservar crÃ©dito via RPC â†’ reserve_credits


9. Scraping â†’ axios + cheerio + timeout 10s


10. Salvar no cache local + remoto


11. Commit da reserva via RPC â†’ commit_reservation


12. Em erro â†’ release_reservation


13. Retornar JSON:



{
  "success": true,
  "analysis": {...},
  "credits_remaining": number,
  "cached": boolean
}

Este Ã© o fluxo obrigatÃ³rio e vocÃª deve implementÃ¡-lo exatamente.


---

ğŸŸ¦ SUAS ENTREGAS (OBRIGATÃ“RIAS)

VocÃª deve implementar tudo abaixo, 100% funcional:


---

âœ” 1. Criar tabelas no Supabase:

analysis_requests

colunas:

id uuid PK

user_id uuid

url

url_normalized

url_hash (varchar(16))

result JSON

status (â€œpendingâ€, â€œsuccessâ€, â€œfailedâ€)

reservation_id uuid

created_at

updated_at



---

analysis_cache

url_hash PK

url

offer_data jsonb

source text

created_at timestamptz



---

credit_reservations

id uuid PK

user_id uuid

amount int default 1

status (â€œreservedâ€, â€œcommittedâ€, â€œreleasedâ€, â€œexpiredâ€)

created_at timestamptz

expire_at timestamptz



---

âœ” 2. Criar RPCs (Postgres, SECURITY DEFINER)

reserve_credits(user_id, amount, ttl_seconds)

â†’ cria reserva
â†’ retorna reservation_id
â†’ NÃƒO debita ainda

commit_reservation(reservation_id)

â†’ debita de verdade
â†’ retorna remaining_credits

release_reservation(reservation_id)

â†’ devolve crÃ©dito ao usuÃ¡rio

Esses RPCs precisam garantir atomicidade usando FOR UPDATE.


---

âœ” 3. Implementar rota /api/analyze completa (Express)

Arquivo recomendado:
backend/routes/analyze.js

A rota deve:

validar JWT via Supabase

normalizar URL

gerar url_hash

checar cache local (SQLite)

checar cache remoto (Supabase)

criar analysis_request

chamar reserve_credits

scraping (axios+cheerio, timeout 10s, 1 retry, user-agent rotativo)

salvar no cache local

salvar no cache remoto

commit_reservation

retornar JSON final



---

âœ” 4. Criar o Cache Local (SQLite)

Arquivo recomendado:
backend/services/cache-sqlite.js

FunÃ§Ãµes obrigatÃ³rias:

getCache(url_hash)

setCache(url_hash, data)

cleanExpiredCache()


TTL padrÃ£o: 24h


---

âœ” 5. Criar o Worker de Scraping (ou funÃ§Ã£o interna)

Arquivo recomendado:
backend/services/scraper.js

Requisitos:

axios + cheerio

timeout 10s

retry 1x com backoff 2s

user-agent rotativo

circuit-breaker de 3 falhas


Retornar:

{ "title": "...", "price": "...", "timestamp": "..." }


---

âœ” 6. Fazer integraÃ§Ã£o Supabase Service Role no backend

Criar arquivo: backend/lib/supabase.js

Usar:

SUPABASE_URL

SUPABASE_SERVICE_ROLE_KEY


O backend NUNCA usa anon-key para debitar crÃ©ditos.


---

âœ” 7. Testes E2E

Gerar script ou instruÃ§Ã£o para:

1. Fazer anÃ¡lise com crÃ©dito suficiente


2. Fazer anÃ¡lise repetida (cache hit)


3. ForÃ§ar erro de scraping (deve liberar reserva)


4. Testar concorrÃªncia (duas requests simultÃ¢neas)


5. Validar crÃ©ditos restantes corretamente




---

ğŸŸ¦ REGRAS DO AGENTE

1. VocÃª deve ler todo o projeto atual.


2. VocÃª deve modificar os arquivos necessÃ¡rios.


3. Retorne DIFFs ou arquivos completos.


4. Retorne tambÃ©m instruÃ§Ãµes de onde colar cada arquivo.


5. Valide o cÃ³digo antes de enviar.


6. Nada de respostas vagas â€” entregue tudo pronto.


7. Se houver falha, corrija automaticamente.




---

ğŸŸ¦ SAÃDA ESPERADA

Quando terminar, vocÃª deve me entregar:

âœ” 1. CÃ³digo completo das tabelas + RPCs

âœ” 2. CÃ³digo completo do backend /api/analyze

âœ” 3. CÃ³digo completo do scraper

âœ” 4. CÃ³digo completo do SQLite cache

âœ” 5. CÃ³digo dos helpers (hash, normalizeUrl, supabase client)

âœ” 6. Registro das rotas no Express

âœ” 7. DiferenÃ§as (DIFF) dos arquivos criados

âœ” 8. Checklist final da execuÃ§Ã£o


---

ğŸŸ¦ INSTRUÃ‡ÃƒO FINAL

Execute todas as etapas acima agora, usando o projeto atual como base.
Ao terminar, devolva:

arquivos completos

diffs

logs

instruÃ§Ãµes de validaÃ§Ã£o


Iniciar.


---